#include "display.h"
#include "AT91SAM7S256.h"
#include "spi.h"
#include <math.h>
#include <string.h>

#define DISPLAY_HEIGHT 64 // Y pixels
#define DISPLAY_WIDTH 100 // X pixels

#define CMD 0
#define DAT 1
#define DISP_LINES (DISPLAY_HEIGHT / 8)

static struct
{
    UBYTE DataArray[DISPLAY_HEIGHT / 8][DISPLAY_WIDTH];
} IOMapDisplay;

UBYTE DisplayInitCommands[] = {
    0xEB, // LCD bias: 1/9=0xEB
    0x2F, // pump control: set build-in=0x2F
    0xA4, // all pixels: off=0xA4, on=0xA5
    0xA6, // inverse: off=0xA6, on=0xA7
    0x40, // set scroll line: 0=0x40-63=0x7F
    0x81, // set Vbias potentiometer (2-byte command): 0x81
    0x5A, //      -"-         		             : on=0x5A, off=0x00
    0xC4, // LCD mapping: regular=0xC4, row-mirror=bit 2, col-mirror=bit 3,
          // e.g. col-mirror=0xC2
    0x27, // set temp comp.: -0.20%/C=0x27
    0x29, // panel loading: <=15nF=0x28, >15nF=0x29
    0xA0, // framerate: 76fps=0xA0, 95fps=0xA1
    0x88, // RAM address control: no wrap around+no autoincrement=0x88
    0x23, // set multiplex rate: 1:65=0x23
    0xAF  // set display: on=0xAF, off=0xAE
};

typedef struct
{
    UBYTE ItemPixelsX;
    UBYTE ItemPixelsY;
    UBYTE Data[];
} __attribute__((__packed__)) FONT, ICON;

const ICON Font = {
    // each character is 6x8 pixels represented as 6 bytes, where each byte is a
    // "column" of 8 pixels
    0x06, // Graphics Width
    0x08, // Graphics Height
    {     /* 32 first non-printable characters */
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
     /* rest printable characters */
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x5F, 0x06, 0x00, 0x00,
     0x07, 0x03, 0x00, 0x07, 0x03, 0x00, 0x24, 0x7E, 0x24, 0x7E, 0x24, 0x00,
     0x24, 0x2B, 0x6A, 0x12, 0x00, 0x00, 0x63, 0x13, 0x08, 0x64, 0x63, 0x00,
     0x30, 0x4C, 0x52, 0x22, 0x50, 0x00, 0x00, 0x07, 0x03, 0x00, 0x00, 0x00,
     0x00, 0x3E, 0x41, 0x00, 0x00, 0x00, 0x00, 0x41, 0x3E, 0x00, 0x00, 0x00,
     0x08, 0x3E, 0x1C, 0x3E, 0x08, 0x00, 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00,
     0x80, 0x60, 0x60, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00,
     0x00, 0x60, 0x60, 0x00, 0x00, 0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00,
     0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00, 0x00, 0x42, 0x7F, 0x40, 0x00, 0x00,
     0x62, 0x51, 0x49, 0x49, 0x46, 0x00, 0x22, 0x49, 0x49, 0x49, 0x36, 0x00,
     0x18, 0x14, 0x12, 0x7F, 0x10, 0x00, 0x2F, 0x49, 0x49, 0x49, 0x31, 0x00,
     0x3C, 0x4A, 0x49, 0x49, 0x30, 0x00, 0x01, 0x71, 0x09, 0x05, 0x03, 0x00,
     0x36, 0x49, 0x49, 0x49, 0x36, 0x00, 0x06, 0x49, 0x49, 0x29, 0x1E, 0x00,
     0x00, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0xEC, 0x6C, 0x00, 0x00, 0x00,
     0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x24, 0x24, 0x24, 0x24, 0x24, 0x00,
     0x00, 0x41, 0x22, 0x14, 0x08, 0x00, 0x02, 0x01, 0x59, 0x09, 0x06, 0x00,
     0x3E, 0x41, 0x5D, 0x55, 0x1E, 0x00, 0x7E, 0x11, 0x11, 0x11, 0x7E, 0x00,
     0x7F, 0x49, 0x49, 0x49, 0x36, 0x00, 0x3E, 0x41, 0x41, 0x41, 0x22, 0x00,
     0x7F, 0x41, 0x41, 0x41, 0x3E, 0x00, 0x7F, 0x49, 0x49, 0x49, 0x41, 0x00,
     0x7F, 0x09, 0x09, 0x09, 0x01, 0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A, 0x00,
     0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00, 0x00, 0x41, 0x7F, 0x41, 0x00, 0x00,
     0x30, 0x40, 0x40, 0x40, 0x3F, 0x00, 0x7F, 0x08, 0x14, 0x22, 0x41, 0x00,
     0x7F, 0x40, 0x40, 0x40, 0x40, 0x00, 0x7F, 0x02, 0x04, 0x02, 0x7F, 0x00,
     0x7F, 0x02, 0x04, 0x08, 0x7F, 0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00,
     0x7F, 0x09, 0x09, 0x09, 0x06, 0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00,
     0x7F, 0x09, 0x09, 0x19, 0x66, 0x00, 0x26, 0x49, 0x49, 0x49, 0x32, 0x00,
     0x01, 0x01, 0x7F, 0x01, 0x01, 0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00,
     0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00, 0x3F, 0x40, 0x3C, 0x40, 0x3F, 0x00,
     0x63, 0x14, 0x08, 0x14, 0x63, 0x00, 0x07, 0x08, 0x70, 0x08, 0x07, 0x00,
     0x71, 0x49, 0x45, 0x43, 0x00, 0x00, 0x00, 0x7F, 0x41, 0x41, 0x00, 0x00,
     0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00, 0x41, 0x41, 0x7F, 0x00, 0x00,
     0x04, 0x02, 0x01, 0x02, 0x04, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00,
     0x00, 0x02, 0x05, 0x02, 0x00, 0x00, 0x20, 0x54, 0x54, 0x54, 0x78, 0x00,
     0x7F, 0x44, 0x44, 0x44, 0x38, 0x00, 0x38, 0x44, 0x44, 0x44, 0x28, 0x00,
     0x38, 0x44, 0x44, 0x44, 0x7F, 0x00, 0x38, 0x54, 0x54, 0x54, 0x08, 0x00,
     0x08, 0x7E, 0x09, 0x09, 0x00, 0x00, 0x18, 0x24, 0xA4, 0xA4, 0xFC, 0x00,
     0x7F, 0x04, 0x04, 0x78, 0x00, 0x00, 0x00, 0x00, 0x7D, 0x40, 0x00, 0x00,
     0x40, 0x80, 0x84, 0x7D, 0x00, 0x00, 0x7F, 0x10, 0x28, 0x44, 0x00, 0x00,
     0x00, 0x00, 0x7F, 0x40, 0x00, 0x00, 0x7C, 0x04, 0x18, 0x04, 0x78, 0x00,
     0x7C, 0x04, 0x04, 0x78, 0x00, 0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x00,
     0xFC, 0x44, 0x44, 0x44, 0x38, 0x00, 0x38, 0x44, 0x44, 0x44, 0xFC, 0x00,
     0x44, 0x78, 0x44, 0x04, 0x08, 0x00, 0x08, 0x54, 0x54, 0x54, 0x20, 0x00,
     0x04, 0x3E, 0x44, 0x24, 0x00, 0x00, 0x3C, 0x40, 0x20, 0x7C, 0x00, 0x00,
     0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00, 0x3C, 0x60, 0x30, 0x60, 0x3C, 0x00,
     0x6C, 0x10, 0x10, 0x6C, 0x00, 0x00, 0x9C, 0xA0, 0x60, 0x3C, 0x00, 0x00,
     0x64, 0x54, 0x54, 0x4C, 0x00, 0x00, 0x08, 0x3E, 0x41, 0x41, 0x00, 0x00,
     0x00, 0x00, 0x77, 0x00, 0x00, 0x00, 0x00, 0x41, 0x41, 0x3E, 0x08, 0x00,
     0x02, 0x01, 0x02, 0x01, 0x00, 0x00, 0x10, 0x20, 0x40, 0x38, 0x07, 0x00}};


void DisplayInit(void)
{
    SPIInit();
    SPIWriteDMA(DisplayInitCommands, sizeof(DisplayInitCommands));
}

void DisplayExit(void)
{
    UBYTE display_off_cmd = 0xAE;
    SPIPIOClearData();
    SPIWriteDMA(&display_off_cmd, 1);
}

void DisplayErase(void)
{
    for (int i = 0; i < DISPLAY_HEIGHT / 8; ++i)
        for (int j = 0; j < DISPLAY_WIDTH; ++j)
            IOMapDisplay.DataArray[i][j] = 0x00;
}

void DisplayUpdateSync(void)
{
    UBYTE reset_col_cmds[2] = {0x00, 0x10};
    UBYTE set_page_cmd;

    SPIPIOClearData();
    SPIWriteDMA(reset_col_cmds, sizeof(reset_col_cmds));

    for (int i = 0; i < DISPLAY_HEIGHT / 8; i++)
    {
        set_page_cmd = 0xB0 + i;

        SPIPIOClearData();
        SPIWriteDMA(reset_col_cmds, sizeof(reset_col_cmds));
        SPIWriteDMA(&set_page_cmd, 1);

        SPIPIOSetData();
        SPIWriteDMA(IOMapDisplay.DataArray[i], DISPLAY_WIDTH);
    }
    SPIPIOClearData();
}

void DisplayChar(UBYTE X, UBYTE Y, UBYTE Char)
{
    const UBYTE *char_ptr = &Font.Data[Font.ItemPixelsX * Char];
    UBYTE current_col;
    for (int i = 0; i < Font.ItemPixelsX; i++)
    {
        current_col = char_ptr[i];
        for (int j = 0; j < Font.ItemPixelsY; j++)
        {
            if (current_col & (0x1 << j))
                DisplaySetPixel(X + i, Y + j);
            else
                DisplayClrPixel(X + i, Y + j);
        }
    }
}

void DisplayNum(UBYTE X, UBYTE Y, ULONG Num)
{
    int digit;
    UBYTE c;
    int digit_count;
    if (Num == 0)
    {
        DisplayChar(X, Y, '0');
        return;
    }
    digit_count = log10(Num) + 1;

    X += (digit_count - 1) * Font.ItemPixelsX;
    while (Num != 0)
    {
        digit = Num % 10;
        c = '0' + digit;
        DisplayChar(X, Y, c);
        Num = Num / 10;
        X -= Font.ItemPixelsX;
    }
}

void DisplayString(UBYTE X, UBYTE Y, UBYTE *pString)
{
    for (int i = 0; i < strlen((char *)pString); i++)
        DisplayChar(X + i * Font.ItemPixelsX, Y, pString[i]);
}

void DisplaySetPixel(UBYTE X, UBYTE Y)
{
    IOMapDisplay.DataArray[Y / 8][X] |= 0x1 << (Y % 8);
}

void DisplayClrPixel(UBYTE X, UBYTE Y)
{
    IOMapDisplay.DataArray[Y / 8][X] &= ~(0x1 << (Y % 8));
}

void DisplayLineX(UBYTE X1, UBYTE X2, UBYTE Y)
{
    for (int i = X1; i <= X2; i++)
        DisplaySetPixel(i, Y);
}

void DisplayLineY(UBYTE X, UBYTE Y1, UBYTE Y2)
{
    for (int i = Y1; i <= Y2; i++)
        DisplaySetPixel(X, i);
}

void DisplayLine(UBYTE X1, UBYTE Y1, UBYTE X2, UBYTE Y2)
{
    float x_s = X2 - X1;
    float y_s = Y2 - Y1;
    float t = 0;
    float interval = 1.0 / 120.0;
    float x;
    float y;
    while (t <= 1)
    {
        x = X1 + t * x_s;
        y = Y1 + t * y_s;
        DisplaySetPixel((UBYTE)floor(x), (UBYTE)floor(y));
        t += interval;
    }
}

void printtime(UBYTE hh, UBYTE mm, UBYTE ss)
{
    UBYTE FontWidth = Font.ItemPixelsX;
    UBYTE FontHeight = Font.ItemPixelsY;

    DisplayString(0, 0, (UBYTE *)"h:");
    if (hh < 10)
    {
        DisplayNum(2 * FontWidth, 0, 0);
        DisplayNum(3 * FontWidth, 0, hh);
    }
    else
        DisplayNum(2 * FontWidth, 0, hh);

    DisplayString(0, FontHeight, (UBYTE *)"m:");
    if (mm < 10)
    {
        DisplayNum(2 * FontWidth, FontHeight, 0);
        DisplayNum(3 * FontWidth, FontHeight, mm);
    }
    else
        DisplayNum(2 * FontWidth, FontHeight, mm);

    DisplayString(0, 2 * FontHeight, (UBYTE *)"s:");
    if (ss < 10)
    {
        DisplayNum(2 * FontWidth, 2 * FontHeight, 0);
        DisplayNum(3 * FontWidth, 2 * FontHeight, ss);
    }
    else
        DisplayNum(2 * FontWidth, 2 * FontHeight, ss);
}
